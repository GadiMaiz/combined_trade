# Import Built-Ins
import logging
import json
import threading
import time

# Import Third-Party
from websocket import create_connection, WebSocketTimeoutException, WebSocketConnectionClosedException
import requests

# Import Homebrew
from bitex.api.WSS.base import WSSAPI

# Init Logging Facilities
log = logging.getLogger(__name__)


class OKCoinWSS(WSSAPI):
    def __init__(self):
        super(OKCoinWSS, self).__init__('wss://real.okcoin.com:10440/websocket/okcoinapi ',
                                        'OKCoin')
        self.conn = None

        self.pairs = ['BTC', 'LTC']
        self._data_thread = None

        self.curr_orders = None

    def start(self):
        super(OKCoinWSS, self).start()

        self._data_thread = threading.Thread(target=self._process_data)
        self._data_thread.daemon = True
        self._data_thread.start()

    def stop(self):
        super(OKCoinWSS, self).stop()

        if self._data_thread.isAlive():
            self._data_thread.join()

    def _process_data(self):
        self.conn = create_connection(self.addr, timeout=4)
        """for pair in self.pairs:
            payload = [{'event': 'addChannel',
                        'channel': 'ok_sub_spotusd_%s_ticker' % pair},
                       {'event': 'addChannel',
                        'channel': 'ok_sub_spotusd_%s_depth_60' % pair},
                       {'event': 'addChannel',
                        'channel': 'ok_sub_spotusd_%s_trades' % pair},
                       {'event': 'addChannel',
                        'channel': 'ok_sub_spotusd_%s_kline_1min' % pair}]

            log.debug(payload)
            self.conn.send(json.dumps(payload))"""

        payload = [{'event': 'addChannel',
                    'channel': 'ok_sub_spot_btc_usd_depth_10'}]
        self.conn.send(json.dumps(payload))
        while self.running:
            try:
                data = json.loads(self.conn.recv())
            except (WebSocketTimeoutException, ConnectionResetError, WebSocketConnectionClosedException):
                self._controller_q.put('restart')
            if len(data) > 0 and 'channel' in data[0]:
                if data[0]['channel'] != 'addChannel':
                    #pair = ''.join(data['channel'].split('spot')[1].split('_')[:2]).upper()
                    #self.data_q.put((data['channel'], pair, data['data'],
                    #                 time.time()))
                    data[0]['data']['asks'].sort(key=lambda x: x[0])
                    self.curr_orders = {'channel' : data[0]['channel'], 'data' : data[0]['data'], 'time' : time.time()}
                    self.data_q.put(self.curr_orders)
            else:
                log.debug(data)
        self.conn = None

    def get_current_partial_book(self, product_id, book_size):
        result = {
            'asks': [],
            'bids': []
        }

        if self.curr_orders != None:
            asks = self.curr_orders['data']['asks']
            bids = self.curr_orders['data']['bids']

            for curr_ask in asks:
                result['asks'].append({'price': float(curr_ask[0]), 'size': float(curr_ask[1])})

            for curr_bid in bids:
                result['bids'].append({'price': float(curr_bid[0]), 'size': float(curr_bid[1])})

        return (result)