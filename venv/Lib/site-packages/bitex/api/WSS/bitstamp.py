# Import Built-Ins
import logging
import json

# Import Third-Party
import pusherclient

# Import Homebrew
from bitex.api.WSS.base import WSSAPI

# Init Logging Facilities
log = logging.getLogger(__name__)


class BitstampWSS(WSSAPI):
    """
    Creates a BitstampWSS Object, which automatically describes to all
    available endpoints of the  Bitstamp Websocket API.

    By Default, data is printed to stdout. If you'd like to customize this
    behaviour, subclass this class, and overwrite the *_callback() methods.

    If you need to have per-channel customization, you will have to overwrite
    the _register_*_channel() methods accordingly.
    """
    def __init__(self, key=None, exclude=None, include_only=None, **kwargs):
        """
        Initializes Instance.

        Pusher Class Attributes:
        :param key: Pusher key, str; stored in self.addr
        :param kwargs: Keyword arguments passed to pusher object.
        """

        key = key if key else 'de504dc5763aeef9ff52'

        super(BitstampWSS, self).__init__(key, 'Bitstamp')

        self.pusher = None
        self.__pusher_options = kwargs

        """
		self.channels = ['live_trades', 'live_trades_btceur',
                         'live_trades_eurusd', 'live_trades_xrpusd',
                         'live_trades_xrpeur', 'live_trades_xrpbtc',
                         'order_book_btceur', 'order_book_eurusd',
                         'order_book_xrpusd', 'order_book_xrpeur',
                         'order_book_xrpbtc', 'diff_order_book', 'order_book',
                         'diff_order_book_btceur', 'diff_order_book_eurusd',
                         'diff_order_book_xrpusd', 'diff_order_book_xrpeur',
                         'diff_order_book_xrpbtc', 'live_orders',
                         'live_orders_btceur', 'live_orders_eurusd',
                         'live_orders_xrpusd', 'live_orders_xrpeur',
                         'live_orders_xrpbtc']
						 """
        self.channels = ['order_book','live_orders']

        if include_only:
            if all(x in self.channels for x in include_only):
                self.channels = include_only
            else:
                raise ValueError("'include_only: must be a list of strings of"
                                 "valid channel name! %s" % self.channels)
        if exclude:
            if all(x in self.channels for x in exclude):
                for x in exclude:
                    self.channels.remove(x)
            else:
                raise ValueError("'exclude: must be a list of strings of"
                                 "valid channel name! %s" % self.channels)
        self.asks = {'BTC' : [], 'BCH' : []}
        self.bids = {'BTC' : [], 'BCH' : []}

    def start(self):
        """
        Extension of Pusher.connect() method, which registers all callbacks with
        the relevant channels, before initializing a connection.
        :return:
        """
        super(BitstampWSS, self).start()

        self.pusher = pusherclient.Pusher(self.addr, **self.__pusher_options)
        self.pusher.connection.bind('pusher:connection_established',
                                    self._register_bindings)
        self.pusher.connect()

    def stop(self):
        super(BitstampWSS, self).stop()
        self.pusher = None

    """
    Custom Callbacks
    """

    def live_trades_callback(self, pair, data):
        """
        This callback is called when data from the live_trades channel is
        received. Overwrite this in children, to change the way data is handled.
        if you require per-pair customization, see the pair-specific callbacks.
        :param pair:
        :param data:
        :return:
        """
        self.data_q.put(('live_trades', pair, data))

    def btcusd_lt_callback(self, data):
        self.live_trades_callback('BTCUSD', data)

    def btceur_lt_callback(self, data):
        self.live_trades_callback('BTCEUR', data)

    def eurusd_lt_callback(self, data):
        self.live_trades_callback('EURUSD', data)

    def xrpusd_lt_callback(self, data):
        self.live_trades_callback('XRPUSD', data)

    def xrpeur_lt_callback(self, data):
        self.live_trades_callback('XRPEUR', data)

    def xrpbtc_lt_callback(self, data):
        self.live_trades_callback('XRPBTC', data)

    """
    Custom Order Book Callback
    """

    def order_book_callback(self, pair, data):
        """
        This callback is called when data from the order_book channel is
        received.
        :param data:
        :return:
        """
        data_dict = json.loads(data)
		
        #print ('ask', data_dict['asks'])
        #print ('bid', data_dict['bids'])
        pair_crypto_type_dict = {'BTCUSD' : 'BTC', 'BCHUSD' : 'BCH'}
        crypto_type = pair_crypto_type_dict[pair]
        self.asks[crypto_type] = data_dict['asks']
        self.bids[crypto_type] = data_dict['bids']
        
        self.data_q.put(('order_book', pair, data))

    def btcusd_ob_callback(self, data):
        self.order_book_callback('BTCUSD', data)

    def btceur_ob_callback(self, data):
        self.order_book_callback('BTCEUR', data)

    def eurusd_ob_callback(self, data):
        self.order_book_callback('EURUSD', data)

    def xrpusd_ob_callback(self, data):
        self.order_book_callback('XRPUSD', data)

    def xrpeur_ob_callback(self, data):
        self.order_book_callback('XRPEUR', data)

    def xrpbtc_ob_callback(self, data):
        self.order_book_callback('XRPBTC', data)

    """
    Custom Diff Order Book Callback
    """

    def diff_order_book_callback(self, pair, data):
        """
        This callback is called when data from the diff_order_book channel is
        received.
        :param pair:
        :param data:
        :return:
        """
        #print(data)
        self.data_q.put(('diff_order_book', pair, data))

    def btcusd_dob_callback(self, data):
        self.diff_order_book_callback('BTCUSD', data)

    def btceur_dob_callback(self, data):
        self.diff_order_book_callback('BTCEUR', data)

    def eurusd_dob_callback(self, data):
        self.diff_order_book_callback('EURUSD', data)

    def xrpusd_dob_callback(self, data):
        self.diff_order_book_callback('XRPUSD', data)

    def xrpeur_dob_callback(self, data):
        self.diff_order_book_callback('XRPEUR', data)

    def xrpbtc_dob_callback(self, data):
        self.diff_order_book_callback('XRPBTC', data)

    """
    Custom Live Orders Callback
    """

    def live_orders_callback(self, pair, data, eventName):
        """
        This callback is called when data from the live_orders channel is
        received.
        :param pair:
        :param data:
        :return:
        """
        #print(eventName, data)
        self.data_q.put(('live_orders', pair, data))

    def btcusd_lo_callback(self, data):
        self.live_orders_callback('BTCUSD', data, '')

    def btcusd_lo_callback_created(self, data):
        self.lo_callback_created("BTC", data)

    def bchusd_lo_callback(self, data):
        self.live_orders_callback('BCHUSD', data, '')

    def bchusd_lo_callback_created(self, data):
        self.lo_callback_created("BCH", data)

    def lo_callback_created(self, crypto_type, data):
        ex_type = ""
        ex_index = -1
        try:
            order_dict = json.loads(data)
            if order_dict['order_type'] == 1:
                ex_type = "ask"
                #print ('new ask', data)
                price = round(order_dict['price'], 2)
                index = 0
                ex_index = index
                while (index < len(self.asks[crypto_type]) and float(self.asks[crypto_type][index][0]) < price):
                    index += 1
                    ex_index = index
                new_ask = ["{0:.2f}".format(price), "{0:.8f}".format(order_dict['amount'])]
                ex_type = "adding ask"
                self.asks[crypto_type][index:index] = [new_ask]
                ex_type = "added ask"
                #print ('new ask added', self.asks)
            else:
                #print ('new bid', data)
                ex_type = "bid"
                price = round(order_dict['price'], 2)
                index = 0
                ex_index = index
                while (index < len(self.bids[crypto_type]) and float(self.bids[crypto_type][index][0]) > price):
                    index += 1
                    ex_index = index
                new_bid = ["{0:.2f}".format(price), "{0:.8f}".format(order_dict['amount'])]
                ex_type = "adding bid"
                self.bids[crypto_type][index:index] = [new_bid]
                ex_type = "added ask"
                #print ('new bid added', self.bids)
        except Exception as inst:
            print ("******************************", type(inst)) # the exception instance
            print (inst.args, "type", ex_type, "index", ex_index, )
        self.live_orders_callback(crypto_type + 'USD', data, 'created')
		
    def btcusd_lo_callback_deleted(self, data):
        self.lo_callback_deleted("BTC", data)

    def bchusd_lo_callback_deleted(self, data):
        self.lo_callback_deleted("BCH", data)

    def lo_callback_deleted(self, crypto_type, data):
        if len(self.asks[crypto_type]) > 0 or len (self.bids[crypto_type]) > 0:
            order_dict = json.loads(data)
            if order_dict['order_type'] == 1:
                #print ('delete ask', data)
                price = round(order_dict['price'], 2)
                index = 0
                while (index < len(self.asks[crypto_type]) and float(self.asks[crypto_type][index][0]) < price):
                    index += 1
                if index < len(self.asks[crypto_type]) and float(self.asks[crypto_type][index][0]) == float(price) and (float(self.asks[crypto_type][index][1]) == float(order_dict['amount']) or (float(order_dict['amount'] == 0))):
                    del self.asks[crypto_type][index]
                #print ('ask deleted', self.asks)
            else:
                #print ('delete bid', data)
                price = round(order_dict['price'], 2)
                index = 0
                while (index < len(self.bids[crypto_type]) and float(self.bids[crypto_type][index][0]) > price):
                    index += 1
                if index < len(self.bids[crypto_type]) and float(self.bids[crypto_type][index][0]) == float(price) and (float(self.bids[crypto_type][index][1]) == float(order_dict['amount']) or (float(order_dict['amount'] == 0))):
                    del self.bids[crypto_type][index]
                #print ('bid deleted', self.bids)
            self.live_orders_callback(crypto_type + 'USD', data, 'deleted')

    def btcusd_lo_callback_changed(self, data):
        self.lo_callback_changed("BTC", data)

    def bchusd_lo_callback_changed(self, data):
        self.lo_callback_changed("BCH", data)

    def lo_callback_changed(self, crypto_type, data):
        if len(self.asks[crypto_type]) > 0 or len (self.bids[crypto_type]) > 0:
            order_dict = json.loads(data)
            if order_dict['order_type'] == 1:
                #print ('change ask', data)
                price = round(order_dict['price'], 2)
                index = 0
                while (index < len(self.asks[crypto_type]) and float(self.asks[crypto_type][index][0]) < price):
                    index += 1
                if index < len(self.asks[crypto_type]) and float(self.asks[crypto_type][index][0]) == float(price):
                    changed_ask = ["{0:.2f}".format(price), "{0:.8f}".format(order_dict['amount'])]
                    self.asks[crypto_type][index] = changed_ask
                #print ('ask changed', self.asks)
            else:
                #print ('change bid', data)
                price = round(order_dict['price'], 2)
                index = 0
                while (index < len(self.bids[crypto_type]) and float(self.bids[crypto_type][index][0]) > price):
                    index += 1
                if index < len(self.bids[crypto_type]) and float(self.bids[crypto_type][index][0]) == float(price):
                    changed_bid = ["{0:.2f}".format(price), "{0:.8f}".format(order_dict['amount'])]
                    self.bids[crypto_type][index] = changed_bid
                #print ('bid changed', self.bids)
            self.live_orders_callback(crypto_type + 'USD', data, 'changed')

    def btceur_lo_callback(self, data):
        self.live_orders_callback('BTCEUR', data)

    def eurusd_lo_callback(self, data):
        self.live_orders_callback('EURUSD', data)

    def xrpusd_lo_callback(self, data):
        self.live_orders_callback('XRPUSD', data)

    def xrpeur_lo_callback(self, data):
        self.live_orders_callback('XRPEUR', data)

    def xrpbtc_lo_callback(self, data):
        self.live_orders_callback('XRPBTC', data)

    """
    Register Methods
    """

    def _register_bindings(self, data):
        """
        connection_handler method which is called when we connect to pusher.
        Responsible for binding callbacks to channels before we connect.
        :return:
        """
        self._register_diff_order_book_channels()
        self._register_live_orders_channels()
        self._register_live_trades_channels()
        self._register_order_book_channels()

    def _bind_channels(self, events, channels):
        """
        Binds given channel events to callbacks.
        :param events: str or list
        :param channels: dict of channel_name: callback_method() pairs
        :return:
        """
        for channel_name in channels:
            if channel_name in self.channels:
                channel = self.pusher.subscribe(channel_name)
                if isinstance(events, list):
                    for event in events:
                        channel.bind(event, channels[channel_name])
                else:
                    channel.bind(events, channels[channel_name])
					
    def _bind_channels_events(self, events, channels):
        """
        Binds given channel events to callbacks.
        :param events: str or list
        :param channels: dict of channel_name: callback_method() pairs
        :return:
        """
        for channel_name in channels:
            if channel_name in channels:
                channel = self.pusher.subscribe(channel_name)
                for event in events:
                    channel.bind(event, events[event])
					
    def _register_live_trades_channels(self):
        """
        Registers the binding for the live_trades_channels channels.
        :return:
        """

        channels = {'live_trades': self.btcusd_lt_callback,
                    'live_trades_btceur': self.btceur_lt_callback,
                    'live_trades_eurusd': self.eurusd_lt_callback,
                    'live_trades_xrpusd': self.xrpusd_lt_callback,
                    'live_trades_xrpeur': self.xrpeur_lt_callback,
                    'live_trades_xrpbtc': self.xrpbtc_lt_callback}

        event = 'trade'
        self._bind_channels(event, channels)

    def _register_order_book_channels(self):
        """
        Registers the binding for the order_book channels.
        :return:
        """
        channels = {'order_book': self.btcusd_ob_callback,
                    'order_book_btceur': self.btceur_ob_callback,
                    'order_book_eurusd': self.eurusd_ob_callback,
                    'order_book_xrpusd': self.xrpusd_ob_callback,
                    'order_book_xrpeur': self.xrpeur_ob_callback,
                    'order_book_xrpbtc': self.xrpbtc_ob_callback}

        event = 'data'
        self._bind_channels(event, channels)

    def _register_diff_order_book_channels(self):
        """
        Registers the binding for the diff_order_book channels.
        :return:
        """
        channels = {'diff_order_book': self.btcusd_dob_callback,
                    'diff_order_book_btceur': self.btceur_dob_callback,
                    'diff_order_book_eurusd': self.eurusd_dob_callback,
                    'diff_order_book_xrpusd': self.xrpusd_dob_callback,
                    'diff_order_book_xrpeur': self.xrpeur_dob_callback,
                    'diff_order_book_xrpbtc': self.xrpbtc_dob_callback}

        event = 'data'
        self._bind_channels(event, channels)

    def _register_live_orders_channels(self):
        channels = {'live_orders': self.btcusd_lo_callback}

        events = {'order_created': self.btcusd_lo_callback_created,
        'order_changed': self.btcusd_lo_callback_changed,
        'order_deleted': self.btcusd_lo_callback_deleted}
        self._bind_channels_events(events, channels)

        bch_channels = {'live_orders_bchusd': self.bchusd_lo_callback}

        bch_events = {'order_created': self.bchusd_lo_callback_created,
                  'order_changed': self.bchusd_lo_callback_changed,
                  'order_deleted': self.bchusd_lo_callback_deleted}
        self._bind_channels_events(bch_events, bch_channels)
        
    def get_current_partial_book(self, crypto_type, book_size):
        partial_asks = self.asks[crypto_type][0:min(book_size, len(self.asks[crypto_type]) - 1)]
        partial_bids = self.bids[crypto_type][0:min(book_size, len(self.bids[crypto_type]) - 1)]
        result = {
            'asks': [],
            'bids': [],
        }

        for curr_ask in partial_asks:
            result['asks'].append({'price' : float(curr_ask[0]), 'size' : float(curr_ask[1]), 'source' : 'Bitstamp'})
            
        for curr_bid in partial_bids:
            result['bids'].append({'price' : float(curr_bid[0]), 'size' : float(curr_bid[1]), 'source' : 'Bitstamp'})
        
        return (result)